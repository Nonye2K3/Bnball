{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-15e1c29d163892e3e5fc7786f74fe5a6a7fb3d40",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/PredictionMarket.sol": "project/contracts/PredictionMarket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/PredictionMarket.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract PredictionMarket {\n    struct Market {\n        uint256 id;\n        string title;\n        string description;\n        string category;\n        uint256 deadline;\n        uint256 yesPool;\n        uint256 noPool;\n        uint256 totalPool;\n        uint256 participants;\n        bool resolved;\n        bool outcome;\n        address creator;\n        uint256 creatorStake;\n        uint256 creatorFeeAccrued;\n    }\n\n    struct Bet {\n        uint256 marketId;\n        bool prediction;\n        uint256 amount;\n        uint256 timestamp;\n        bool claimed;\n    }\n\n    // Constants\n    uint256 public constant PLATFORM_FEE_BP = 1000; // 10% in basis points\n    uint256 public constant CREATOR_FEE_BP = 200;   // 2% in basis points\n    uint256 public constant BASIS_POINTS = 10000;\n    \n    uint256 public minBetAmount = 0.01 ether;\n    uint256 public createMarketStake = 0.1 ether;\n    uint256 public registrationFeeUSD = 2; // $2 USD\n    uint256 public marketCount;\n    \n    address public owner;\n    address public immutable platformFeeRecipient;\n    AggregatorV3Interface public immutable bnbUsdPriceFeed;\n    \n    mapping(uint256 => Market) public markets;\n    mapping(address => Bet[]) public userBets;\n    mapping(uint256 => mapping(address => Bet)) public marketUserBets;\n    mapping(uint256 => mapping(bool => uint256)) public marketPools;\n    mapping(address => bool) public registeredUsers;\n    \n    event MarketCreated(uint256 indexed marketId, address indexed creator, string title, uint256 deadline);\n    event BetPlaced(uint256 indexed marketId, address indexed bettor, bool prediction, uint256 amount, uint256 platformFee, uint256 creatorFee);\n    event MarketResolved(uint256 indexed marketId, bool outcome);\n    event WinningsClaimed(uint256 indexed marketId, address indexed winner, uint256 amount);\n    event UserRegistered(address indexed user, uint256 feePaid);\n    event PlatformFeeCollected(uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this\");\n        _;\n    }\n\n    modifier marketExists(uint256 marketId) {\n        require(marketId > 0 && marketId <= marketCount, \"Market does not exist\");\n        _;\n    }\n\n    modifier marketNotResolved(uint256 marketId) {\n        require(!markets[marketId].resolved, \"Market already resolved\");\n        _;\n    }\n\n    modifier beforeDeadline(uint256 marketId) {\n        require(block.timestamp < markets[marketId].deadline, \"Market deadline passed\");\n        _;\n    }\n\n    modifier afterDeadline(uint256 marketId) {\n        require(block.timestamp >= markets[marketId].deadline, \"Market deadline not passed\");\n        _;\n    }\n\n    modifier requiresRegistration() {\n        require(registeredUsers[msg.sender], \"User must register first\");\n        _;\n    }\n\n    constructor(address _platformFeeRecipient, address _bnbUsdPriceFeed) {\n        require(_platformFeeRecipient != address(0), \"Invalid platform fee recipient\");\n        require(_bnbUsdPriceFeed != address(0), \"Invalid price feed address\");\n        \n        owner = msg.sender;\n        platformFeeRecipient = _platformFeeRecipient;\n        bnbUsdPriceFeed = AggregatorV3Interface(_bnbUsdPriceFeed);\n        marketCount = 0;\n        \n        // Owner is pre-registered\n        registeredUsers[msg.sender] = true;\n    }\n\n    /**\n     * @notice Register user with $2 USD equivalent in BNB\n     * @dev Uses Chainlink BNB/USD oracle to convert USD to BNB\n     */\n    function registerUser() external payable {\n        require(!registeredUsers[msg.sender], \"User already registered\");\n        \n        uint256 requiredBNB = getRegistrationFeeInBNB();\n        require(msg.value >= requiredBNB, \"Insufficient registration fee\");\n        \n        registeredUsers[msg.sender] = true;\n        \n        // Send registration fee to platform\n        (bool success, ) = payable(platformFeeRecipient).call{value: msg.value}(\"\");\n        require(success, \"Failed to send registration fee\");\n        \n        emit UserRegistered(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Get current BNB/USD price from Chainlink oracle\n     * @return price BNB/USD price with 8 decimals\n     */\n    function getBNBUSDPrice() public view returns (uint256) {\n        (, int256 price, , uint256 updatedAt, ) = bnbUsdPriceFeed.latestRoundData();\n        require(price > 0, \"Invalid price feed\");\n        require(block.timestamp - updatedAt <= 1 hours, \"Price feed stale\");\n        return uint256(price);\n    }\n\n    /**\n     * @notice Calculate registration fee in BNB\n     * @return fee Registration fee in BNB (wei)\n     */\n    function getRegistrationFeeInBNB() public view returns (uint256) {\n        uint256 bnbUsdPrice = getBNBUSDPrice(); // 8 decimals\n        // registrationFeeUSD is in dollars, bnbUsdPrice has 8 decimals\n        // fee = (registrationFeeUSD * 10^26) / bnbUsdPrice\n        // This gives us BNB in wei (18 decimals)\n        return (registrationFeeUSD * 1e26) / bnbUsdPrice;\n    }\n\n    function createMarket(\n        string memory title,\n        string memory description,\n        string memory category,\n        uint256 deadline\n    ) external payable requiresRegistration returns (uint256 marketId) {\n        require(msg.value == createMarketStake, \"Must send exact stake amount\");\n        require(deadline > block.timestamp, \"Deadline must be in the future\");\n        require(bytes(title).length >= 10, \"Title too short\");\n        require(bytes(description).length >= 50, \"Description too short\");\n\n        marketCount++;\n        marketId = marketCount;\n\n        markets[marketId] = Market({\n            id: marketId,\n            title: title,\n            description: description,\n            category: category,\n            deadline: deadline,\n            yesPool: 0,\n            noPool: 0,\n            totalPool: 0,\n            participants: 0,\n            resolved: false,\n            outcome: false,\n            creator: msg.sender,\n            creatorStake: msg.value,\n            creatorFeeAccrued: 0\n        });\n\n        emit MarketCreated(marketId, msg.sender, title, deadline);\n        return marketId;\n    }\n\n    function placeBet(uint256 marketId, bool prediction)\n        external\n        payable\n        requiresRegistration\n        marketExists(marketId)\n        marketNotResolved(marketId)\n        beforeDeadline(marketId)\n    {\n        require(msg.value >= minBetAmount, \"Bet amount too low\");\n        require(marketUserBets[marketId][msg.sender].amount == 0, \"Already bet on this market\");\n\n        Market storage market = markets[marketId];\n        \n        // Calculate fees: 10% platform + 2% creator = 12% total\n        uint256 platformFee = (msg.value * PLATFORM_FEE_BP) / BASIS_POINTS; // 10%\n        uint256 creatorFee = (msg.value * CREATOR_FEE_BP) / BASIS_POINTS;   // 2%\n        uint256 betAmount = msg.value - platformFee - creatorFee;            // 88%\n        \n        // Send platform fee immediately\n        (bool success, ) = payable(platformFeeRecipient).call{value: platformFee}(\"\");\n        require(success, \"Failed to send platform fee\");\n        \n        // Accrue creator fee (paid on resolution)\n        market.creatorFeeAccrued += creatorFee;\n        \n        // Add bet amount to pools (88% of original bet)\n        if (prediction) {\n            market.yesPool += betAmount;\n            marketPools[marketId][true] += betAmount;\n        } else {\n            market.noPool += betAmount;\n            marketPools[marketId][false] += betAmount;\n        }\n        \n        market.totalPool += betAmount;\n        market.participants++;\n\n        Bet memory newBet = Bet({\n            marketId: marketId,\n            prediction: prediction,\n            amount: msg.value, // Store original amount for user reference\n            timestamp: block.timestamp,\n            claimed: false\n        });\n\n        userBets[msg.sender].push(newBet);\n        marketUserBets[marketId][msg.sender] = newBet;\n\n        emit BetPlaced(marketId, msg.sender, prediction, msg.value, platformFee, creatorFee);\n        emit PlatformFeeCollected(platformFee);\n    }\n\n    function resolveMarket(uint256 marketId, bool outcome)\n        external\n        onlyOwner\n        marketExists(marketId)\n        marketNotResolved(marketId)\n        afterDeadline(marketId)\n    {\n        Market storage market = markets[marketId];\n        \n        market.resolved = true;\n        market.outcome = outcome;\n\n        // Pay creator: stake refund + accrued 2% creator fees\n        uint256 totalPayout = market.creatorStake + market.creatorFeeAccrued;\n\n        emit MarketResolved(marketId, outcome);\n\n        (bool success, ) = payable(market.creator).call{value: totalPayout}(\"\");\n        require(success, \"Failed to send funds to creator\");\n    }\n\n    function claimWinnings(uint256 marketId)\n        external\n        marketExists(marketId)\n    {\n        Market storage market = markets[marketId];\n        require(market.resolved, \"Market not resolved yet\");\n\n        Bet storage userBet = marketUserBets[marketId][msg.sender];\n        require(userBet.amount > 0, \"No bet found\");\n        require(!userBet.claimed, \"Winnings already claimed\");\n\n        uint256 winningPool = market.outcome ? market.yesPool : market.noPool;\n        uint256 losingPool = market.outcome ? market.noPool : market.yesPool;\n        \n        // Calculate user's share from the 88% pool (after 12% fees)\n        uint256 platformFee = (userBet.amount * PLATFORM_FEE_BP) / BASIS_POINTS;\n        uint256 creatorFee = (userBet.amount * CREATOR_FEE_BP) / BASIS_POINTS;\n        uint256 userBetInPool = userBet.amount - platformFee - creatorFee;\n        \n        uint256 winnings;\n\n        if (winningPool == 0) {\n            // No winners, losers get refund from losing pool\n            require(userBet.prediction != market.outcome, \"No winners to claim from\");\n            winnings = (userBetInPool * market.totalPool) / losingPool;\n        } else {\n            // Normal case: winners split the entire pool\n            require(userBet.prediction == market.outcome, \"Bet lost\");\n            winnings = (userBetInPool * market.totalPool) / winningPool;\n        }\n\n        userBet.claimed = true;\n\n        for (uint i = 0; i < userBets[msg.sender].length; i++) {\n            if (userBets[msg.sender][i].marketId == marketId) {\n                userBets[msg.sender][i].claimed = true;\n                break;\n            }\n        }\n\n        emit WinningsClaimed(marketId, msg.sender, winnings);\n\n        (bool success, ) = payable(msg.sender).call{value: winnings}(\"\");\n        require(success, \"Failed to send winnings\");\n    }\n\n    function getMarketDetails(uint256 marketId)\n        external\n        view\n        marketExists(marketId)\n        returns (Market memory)\n    {\n        return markets[marketId];\n    }\n\n    function getUserBets(address user) external view returns (Bet[] memory) {\n        return userBets[user];\n    }\n\n    function getUserBetInMarket(uint256 marketId, address user)\n        external\n        view\n        returns (bool hasBet, bool prediction, uint256 amount, bool claimed)\n    {\n        Bet memory bet = marketUserBets[marketId][user];\n        if (bet.amount == 0) {\n            return (false, false, 0, false);\n        }\n        return (true, bet.prediction, bet.amount, bet.claimed);\n    }\n\n    function isUserRegistered(address user) external view returns (bool) {\n        return registeredUsers[user];\n    }\n\n    function updateMinBetAmount(uint256 newMinBet) external onlyOwner {\n        minBetAmount = newMinBet;\n    }\n\n    function updateCreateMarketStake(uint256 newStake) external onlyOwner {\n        createMarketStake = newStake;\n    }\n\n    function updateRegistrationFeeUSD(uint256 newFeeUSD) external onlyOwner {\n        require(newFeeUSD >= 1 && newFeeUSD <= 100, \"Fee must be between $1 and $100\");\n        registrationFeeUSD = newFeeUSD;\n    }\n\n    receive() external payable {}\n}\n"
      }
    }
  }
}