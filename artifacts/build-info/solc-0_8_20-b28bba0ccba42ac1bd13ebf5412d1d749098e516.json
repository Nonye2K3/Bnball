{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-b28bba0ccba42ac1bd13ebf5412d1d749098e516",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/PredictionMarket.sol": "project/contracts/PredictionMarket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PredictionMarket.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract PredictionMarket {\n    struct Market {\n        uint256 id;\n        string title;\n        string description;\n        string category;\n        uint256 deadline;\n        uint256 yesPool;\n        uint256 noPool;\n        uint256 totalPool;\n        uint256 participants;\n        bool resolved;\n        bool outcome;\n        address creator;\n        uint256 creatorStake;\n    }\n\n    struct Bet {\n        uint256 marketId;\n        bool prediction;\n        uint256 amount;\n        uint256 timestamp;\n        bool claimed;\n    }\n\n    uint256 public minBetAmount = 0.5 ether;\n    uint256 public createMarketStake = 1.0 ether;\n    uint256 public marketCount;\n    address public owner;\n    \n    mapping(uint256 => Market) public markets;\n    mapping(address => Bet[]) public userBets;\n    mapping(uint256 => mapping(address => Bet)) public marketUserBets;\n    mapping(uint256 => mapping(bool => uint256)) public marketPools;\n    \n    event MarketCreated(uint256 indexed marketId, address indexed creator, string title, uint256 deadline);\n    event BetPlaced(uint256 indexed marketId, address indexed bettor, bool prediction, uint256 amount);\n    event MarketResolved(uint256 indexed marketId, bool outcome);\n    event WinningsClaimed(uint256 indexed marketId, address indexed winner, uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this\");\n        _;\n    }\n\n    modifier marketExists(uint256 marketId) {\n        require(marketId > 0 && marketId <= marketCount, \"Market does not exist\");\n        _;\n    }\n\n    modifier marketNotResolved(uint256 marketId) {\n        require(!markets[marketId].resolved, \"Market already resolved\");\n        _;\n    }\n\n    modifier beforeDeadline(uint256 marketId) {\n        require(block.timestamp < markets[marketId].deadline, \"Market deadline passed\");\n        _;\n    }\n\n    modifier afterDeadline(uint256 marketId) {\n        require(block.timestamp >= markets[marketId].deadline, \"Market deadline not passed\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        marketCount = 0;\n    }\n\n    function createMarket(\n        string memory title,\n        string memory description,\n        string memory category,\n        uint256 deadline\n    ) external payable returns (uint256 marketId) {\n        require(msg.value == createMarketStake, \"Must send exact stake amount\");\n        require(deadline > block.timestamp, \"Deadline must be in the future\");\n        require(bytes(title).length >= 10, \"Title too short\");\n        require(bytes(description).length >= 50, \"Description too short\");\n\n        marketCount++;\n        marketId = marketCount;\n\n        markets[marketId] = Market({\n            id: marketId,\n            title: title,\n            description: description,\n            category: category,\n            deadline: deadline,\n            yesPool: 0,\n            noPool: 0,\n            totalPool: 0,\n            participants: 0,\n            resolved: false,\n            outcome: false,\n            creator: msg.sender,\n            creatorStake: msg.value\n        });\n\n        emit MarketCreated(marketId, msg.sender, title, deadline);\n        return marketId;\n    }\n\n    function placeBet(uint256 marketId, bool prediction)\n        external\n        payable\n        marketExists(marketId)\n        marketNotResolved(marketId)\n        beforeDeadline(marketId)\n    {\n        require(msg.value >= minBetAmount, \"Bet amount too low\");\n        require(marketUserBets[marketId][msg.sender].amount == 0, \"Already bet on this market\");\n\n        Market storage market = markets[marketId];\n        \n        if (prediction) {\n            market.yesPool += msg.value;\n            marketPools[marketId][true] += msg.value;\n        } else {\n            market.noPool += msg.value;\n            marketPools[marketId][false] += msg.value;\n        }\n        \n        market.totalPool += msg.value;\n        market.participants++;\n\n        Bet memory newBet = Bet({\n            marketId: marketId,\n            prediction: prediction,\n            amount: msg.value,\n            timestamp: block.timestamp,\n            claimed: false\n        });\n\n        userBets[msg.sender].push(newBet);\n        marketUserBets[marketId][msg.sender] = newBet;\n\n        emit BetPlaced(marketId, msg.sender, prediction, msg.value);\n    }\n\n    function resolveMarket(uint256 marketId, bool outcome)\n        external\n        onlyOwner\n        marketExists(marketId)\n        marketNotResolved(marketId)\n        afterDeadline(marketId)\n    {\n        Market storage market = markets[marketId];\n        \n        market.resolved = true;\n        market.outcome = outcome;\n\n        uint256 totalPayout = market.creatorStake;\n        \n        if (market.totalPool > 0) {\n            uint256 creatorFee = (market.totalPool * 5) / 1000;\n            totalPayout += creatorFee;\n        }\n\n        emit MarketResolved(marketId, outcome);\n\n        (bool success, ) = payable(market.creator).call{value: totalPayout}(\"\");\n        require(success, \"Failed to send funds to creator\");\n    }\n\n    function claimWinnings(uint256 marketId)\n        external\n        marketExists(marketId)\n    {\n        Market storage market = markets[marketId];\n        require(market.resolved, \"Market not resolved yet\");\n\n        Bet storage userBet = marketUserBets[marketId][msg.sender];\n        require(userBet.amount > 0, \"No bet found\");\n        require(!userBet.claimed, \"Winnings already claimed\");\n\n        uint256 winningPool = market.outcome ? market.yesPool : market.noPool;\n        uint256 losingPool = market.outcome ? market.noPool : market.yesPool;\n        \n        uint256 creatorFee = (market.totalPool * 5) / 1000;\n        uint256 availablePool = market.totalPool - creatorFee;\n        uint256 winnings;\n\n        if (winningPool == 0) {\n            require(userBet.prediction != market.outcome, \"No winners to claim from\");\n            winnings = (userBet.amount * availablePool) / losingPool;\n        } else {\n            require(userBet.prediction == market.outcome, \"Bet lost\");\n            winnings = (userBet.amount * availablePool) / winningPool;\n        }\n\n        userBet.claimed = true;\n\n        for (uint i = 0; i < userBets[msg.sender].length; i++) {\n            if (userBets[msg.sender][i].marketId == marketId) {\n                userBets[msg.sender][i].claimed = true;\n                break;\n            }\n        }\n\n        emit WinningsClaimed(marketId, msg.sender, winnings);\n\n        (bool success, ) = payable(msg.sender).call{value: winnings}(\"\");\n        require(success, \"Failed to send winnings\");\n    }\n\n    function getMarketDetails(uint256 marketId)\n        external\n        view\n        marketExists(marketId)\n        returns (Market memory)\n    {\n        return markets[marketId];\n    }\n\n    function getUserBets(address user) external view returns (Bet[] memory) {\n        return userBets[user];\n    }\n\n    function getUserBetInMarket(uint256 marketId, address user)\n        external\n        view\n        returns (bool hasBet, bool prediction, uint256 amount, bool claimed)\n    {\n        Bet memory bet = marketUserBets[marketId][user];\n        if (bet.amount == 0) {\n            return (false, false, 0, false);\n        }\n        return (true, bet.prediction, bet.amount, bet.claimed);\n    }\n\n    function updateMinBetAmount(uint256 newMinBet) external onlyOwner {\n        minBetAmount = newMinBet;\n    }\n\n    function updateCreateMarketStake(uint256 newStake) external onlyOwner {\n        createMarketStake = newStake;\n    }\n\n    receive() external payable {}\n}\n"
      }
    }
  }
}